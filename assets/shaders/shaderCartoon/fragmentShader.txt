//Especificar version de Opengl a utilizar
#version 330 core

// Variable de salida del Fragment
out vec4 FragColor; //Color final del fragmento

// Variables de entrada desde el VertexShader
in data{
    vec2 textCoords; //Coordenadas de textura
    vec3 worldPos; // Fragmento en coordenadas del mundo 
    vec3 worldNormal; //Normal del Fragmento en coordenadas del mundo
} fs_in;

//Estructura para definir luces
struct Light {
    vec3 position; //Posicion de la luz
    vec4 direction; //Direccion de la luz -> para luces dirigidas

    vec3 ambient; //Componente ambiente de la luz
    vec3 diffuse; //Componente difusa de la luz
    vec3 specular; //Componente specular de la luz

    float k; //Variable para el control de la atenuacion
    float cut; //Coseno del angulo que define el radio del foco de la luz dirigida

    bool sombra; //true == sombra activada, false == luz sin sombra
    bool activa; //true == luz activada, false == luz apagada

    mat4 lightMatrix; //Matriz de luz para cada luz dirigida
};

//Estructura con los datos del material
struct Material{
    //Componentes de color del material
    vec4 color_ambient;
    vec4 color_diffuse;
    vec4 color_specular;
    
    float brightness; //Brillo del material -> para el calculo de la la componente especular de la luz
};

const int numLights = 4;
uniform Light point_lights[numLights]; //Vector de luces puntuales
uniform samplerCube shadowCube_0; //Cubo de profundidad para el calculo de las sombras de la luz puntual 0
uniform samplerCube shadowCube_1; //Cubo de profundidad para el calculo de las sombras de la luz puntual 1
uniform samplerCube shadowCube_2; //Cubo de profundidad para el calculo de las sombras de la luz puntual 2
uniform samplerCube shadowCube_3; //Cubo de profundidad para el calculo de las sombras de la luz puntual 3
uniform Light spot_lights[numLights]; //Vector de luces dirigidas
uniform sampler2D shadowMap_0; //Textura con el mapa de profundidad para el calculo de las sombras de la luz dirigida 0
uniform sampler2D shadowMap_1; //Textura con el mapa de profundidad para el calculo de las sombras de la luz dirigida 1
uniform sampler2D shadowMap_2; //Textura con el mapa de profundidad para el calculo de las sombras de la luz dirigida 2
uniform sampler2D shadowMap_3; //Textura con el mapa de profundidad para el calculo de las sombras de la luz dirigida 3

uniform Material material; //Material de la malla para cada vertice
uniform vec3 posCamera; //Posicion de la camara
uniform sampler2D texture_diffuse; //Textura difusa de la malla
uniform sampler2D texture_specular; //Textura especular de la malla
uniform sampler2D texture_normal; //Textura de normales de la malla
uniform float planoLejano; //Plano lejano de la matriz de proyeccion perspectiva usada para renderizar el cubo de profundidad

//Niveles para comparar la componente difusa
const float A = 0.1;
const float B = 0.3;
const float C = 0.6;
const float D = 1.0;

//Declaracion de funciones
vec3 calculatePointLight(int i);
vec3 calculateSpotlight(int i, vec3 N);
float calculatePointShadows(samplerCube c, int luz, vec3 N);

void main()
{    
    //Color final del pixel
    vec3 finalColor;
    finalColor = vec3(0.0, 0.0, 0.0);

    //======================================================
    // CALCULO DE LA LUZ: MODELO DE PHONG
    //======================================================
    vec3 result = vec3(0.0, 0.0, 0.0);

    //Bucle que recorre las luces puntuales
    for (int i = 0; i < numLights; i++){
        result = vec3(0.0, 0.0, 0.0);
        //Si la luz esta activa, se calcula su influencia sobre el fragmento
        if ( point_lights[i].activa == true){
            result = calculatePointLight(i);
            
        }
        //Luz resultante: ambient+diffuse+specular (se va acumulando)
        finalColor = finalColor + result;
    }

    //Se asigna el color resultante a la variable de salida
    FragColor = vec4(finalColor, 1.0);
}


//Funcion que calcula la influencia de una luz puntual sobre el fragmento
vec3 calculatePointLight(int i){

        // ---- AMBIENTE ----
        //Se multiplica la componente ambiente de la luz por el color ambiente del material del pixel para calcular la incidencia de la luz difusa
        //Solo se multiplica por la componente ambiente de la primera luz, sino la escena se satura demasiado
        vec3 ambient = point_lights[i].ambient * vec3(texture(texture_diffuse, fs_in.textCoords));
        
        // ----- DIFUSA -----
        //Calcular la direccion entre la fuente de luz y la posicion en el mundo del vertice
        vec3 lightDirection = normalize(point_lights[i].position - fs_in.worldPos);     //|Se necesitan normalizar los vectores
        vec3 N = normalize(fs_in.worldNormal);                                   //|para que sean unitarios

        //Calcular productor escalar entre la direccion de la luz y el vector normal normalizado
        //para obtener la influencia de la luz difusa sobre cada superficie
        //max = no queremos el valor negativo del resultado
        float scalar = max(dot(N, lightDirection), 0.0);
        //Comparamos el factor difuso con los rangos anteriores, de manera que conforme va siendo mayor o menor, le asignamos un valor predefinido
        if (scalar < A) scalar = 0.1;
        else if (scalar < B) scalar = B; //0.3
        else if (scalar < C) scalar = C; //0.6
        else scalar = D; //1.0

        //Lo multiplicamos por la textura difusa
        vec3 diffuse = point_lights[i].diffuse * scalar * vec3(texture(texture_diffuse, fs_in.textCoords));
        
        // ---- ESPECULAR ----
        //Calcular la direccion entre la camara y la posicion en el mundo del vertice
        vec3 cameraDirection = normalize(posCamera - fs_in.worldPos);
        //Calcular el reflejo del vector direccion de la luz con la normal
        vec3 directionReflect = reflect(-lightDirection, N);

        //Calcular el componente especular
        float S = pow(max(dot(cameraDirection, directionReflect), 0.0), material.brightness);
        //Si el factor especular es menor que 0.5, lo asignamo a 0, sino a uno
        if (S < 0.5){
            S = 0.0;
        }else{
            S = 1.0;
        }
        //Lo multiplicamos por la textura especular
        vec3 specular = point_lights[i].specular * S * vec3(texture(texture_specular, fs_in.textCoords));

        // ---- SOMBRAS ----
        //Calculamos el valor de la sombra
        float shadow = 0.0;
        //Segun la luz que estemos tratando, se usa el cubo de profundidad correspondiente, siempre que se requiera que la luz tenga sombras
        if ( i == 0 ){
            if ( point_lights[i].sombra == true )
            shadow = calculatePointShadows(shadowCube_0, i, N);
        } else if ( i == 1 ){
            if ( point_lights[i].sombra == true )
            shadow = calculatePointShadows(shadowCube_1, i, N);
        } else if ( i == 2 ){
            if ( point_lights[i].sombra == true )
            shadow = calculatePointShadows(shadowCube_2, i, N);
        } else if ( i == 3 ){
            if ( point_lights[i].sombra == true )
            shadow = calculatePointShadows(shadowCube_3, i, N);
        }
        //Lo multiplicamos por las componentes difusa y especular
        diffuse = (1.0 - shadow) * diffuse;
        specular = (1.0 - shadow) * specular;

        //Resultado del calculo de la luz
        vec3 r = ambient + diffuse + specular;

        return r;
}

//Funcion para el calculo de las sombras de una luz dirigida. Devuelve un float (grado de penumbra) que se multiplica por las 
//componentes difusa y especular de la luz 
float calculatePointShadows(samplerCube c, int luz, vec3 N){
    //Vector direccion entre el fragmento y la luz
    vec3 fragToLight = fs_in.worldPos - point_lights[luz].position; 
    //Despues, obtenemos la profundidad del fragmento actual (longitud del vector anterior)
    float aDepth = length(fragToLight);
    //BIAS = Variable que sirve como rango para evitar el problema del acne en el dibujado de las sombras
    //Sin ella, se dibujan finas lineas negras por toda la escena iluminada, produciendo un efecto parecido a una teselacion
    float bias = 0.005;
    //Supermuestreo para definir los bordes de las sombras (PCF con un numero determinado de muestras)
    int nMuestras  = 20; //Numero de muestra 
    //array de vec3 con las direcciones de muestra
    vec3 direccionesMuestra[20] = vec3[](vec3( 1,  1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1,  1,  1), 
    vec3( 1,  1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1,  1, -1), vec3( 1,  1,  0), vec3( 1, -1,  0), 
    vec3(-1, -1,  0), vec3(-1,  1,  0), vec3( 1,  0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1,  0, -1),
    vec3( 0,  1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0,  1, -1));
    float shadow = 0.0;
    float d = length(posCamera - fs_in.worldPos); //Distancia entre la camara y el fragmento
    float radio = 0.1;  //Radio alrededor del vector entre la luz y el fragmento que se va a muestrear
                        //Cuanto mas alto, sombras mas difuminadas
    for(int i = 0; i < nMuestras; i++)
    {
        //Obtenemos la profundidad del cubo a partir del vector entre la posicion del fragmento y de la luz
        float cubeDepth = texture(c, fragToLight + direccionesMuestra[i] * radio).r; //Nos devuelve la profundidad en el rango [0,1]
        cubeDepth *= planoLejano; //La multiplicamos por el plano lejano para obtenerla en el rango [0, planoLejano]
        //Si la profundidad del fragmento es mayor que la profundidad mas cercana desde la perspectiva de la luz,
        //entonces el fragmento se encuentro en penumbra
        if(aDepth - bias > cubeDepth)
            shadow = shadow + 1.0;
    }
    //Dividimos el valor de sombra entre el numero de muestras tratadas para hacer la media
    shadow = shadow/float(nMuestras);  
    //Puntos que estan fuera del circulo cumplen que: (x - center_x)^2 + (y - center_y)^2 < radius^2
    //Para evitar el sombreado de las zonas del mapa exteriores al plano lejano utilizado en la matriz proyeccion de la luz
    if ((pow(fragToLight.x,2) + pow(fragToLight.z,2)) > pow(planoLejano-1.0, 2)) shadow = 0.0;

    return shadow;
}