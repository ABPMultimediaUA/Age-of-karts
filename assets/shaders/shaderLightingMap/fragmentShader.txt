//Especificar version de Opengl a utilizar
#version 330 core

// Variable de salida del Fragment
out vec4 FragColor; //Color final del pixel

// Variables de entrada desde el VertexShader
in data{
    vec2 textCoords; //Coordenadas de textura
    vec3 worldPos; // Vertice en coordenadas del mundo 
    vec3 worldNormal; //Normal del vertice en coordenadas del mundo
    vec4 worldLightPos; //Vertice en coordenadas de la luz
    mat3 tbnMatrix; //Inversa de la matriz TBN
} fs_in;

//Estructura para definir luces
struct Light {
    vec3 position; //Posicion de la luz
    vec4 direction; //Direccion de la luz -> para luces dirigidas

    vec3 ambient; //Componente ambiente de la luz
    vec3 diffuse; //Componente difusa de la luz
    vec3 specular; //Componente specular de la luz

    float k; //Variable para el control de la atenuacion
    float cut; //Coseno del angulo que define el radio del foco de la luz dirigida
};

//Estructura con los datos del material
struct Material{
    //Componentes de color del material
    vec4 color_ambient;
    vec4 color_diffuse;
    vec4 color_specular;
    //Brillo del material -> para el calculo de la la componente especular de la luz
    float brightness;
};

const int num_lights = 8; //Numero de luces posibles de la escena
uniform Light light[num_lights]; //Vector de luces

uniform Material material; //Material de la malla para cada vertice
uniform vec3 posCamera; //Posicion de la camara
uniform sampler2D texture_diffuse; //Textura difusa de la malla
uniform sampler2D texture_specular; //Textura especular de la malla
uniform sampler2D texture_normal; //Textura de normales de la malla
uniform sampler2D shadowMap; //Textura con el mapa de profundidad para el calculo de las sombras

//Declaracion de funciones
vec3 calculatePointLight(int i, vec3 N);
vec3 calculateSpotlight(int i, vec3 N);
float calculateShadows(vec4 Lpos, int luz, vec3 N);

void main()
{    

    //Color final del pixel
    vec3 finalColor;
    finalColor = vec3(0.0, 0.0, 0.0);

    //Vector normal de cada vertice recogido a partir del mapa de normales y las coordenadas de textura
    vec3 normal = texture(texture_normal, fs_in.textCoords).rgb;
    //Transformar el vector al rango de coordenadas [-1,1]
    vec3 N = normalize(normal * 2.0 -1.0);

    //======================================================
    // CALCULO DE LA LUZ: MODELO DE PHONG
    //======================================================

    //Bucle para recorrer todas las luces de la escena y calcularla la influencia de cada una en el color del pixel
    for (int i = 0; i < num_lights; i++){

        vec3 result;
        //Si la componente w de la direccion de la luz es 0, significa que es una luz puntual
        //En caso contrario, se trata de una luz dirigida
        if ( light[i].direction.w < 0.1){
            result = calculatePointLight(i, N);
        }else{
            result = calculateSpotlight(i, N);
        }

        //Luz resultante: ambient+diffuse+specular (se va acumulando)
        finalColor = finalColor + result;

    }

    //Se asigna el color resultante a la variable de salida
    //FragColor = vec4(vec3(texture(texture_diffuse, fs_in.textCoords)), 1.0);
    FragColor = vec4(finalColor, 1.0);
}

//Funcion que calcula la influencia de una luz puntual sobre el vertice
vec3 calculatePointLight(int i, vec3 N){

        // *** ATENUACION ***
        // a = 1/(1+kd²), donde d es la distancia entre la luz y el vertice y k es una constante predefinida por nosotros para controlar la atenuacion
        // Tras calcularla, la atenuacion debe multiplicarse por la componente ambiente, difusa y especular de la luz
        float d = length(light[i].position - fs_in.worldPos);
        float attenuation = 1.0 / (1.0 + (light[i].k * pow(d,2))); 

        // ---- AMBIENTE ----
        //Se multiplica la componente ambiente de la luz por el color ambiente del material del pixel para calcular la incidencia de la luz difusa
        //Solo se multiplica por la componente ambiente de la primera luz, sino la escena se satura demasiado
        vec3 ambient = light[i].ambient * vec3(texture(texture_diffuse, fs_in.textCoords));
        ambient *= attenuation;
        
        // ----- DIFUSA -----
        //Calcular la direccion entre la fuente de luz y la posicion en el mundo del vertice
        //Despues, la multiplicamos por la inversa de la TBN para pasarla a espacio tangente
        vec3 lightDirection = fs_in.tbnMatrix * normalize(light[i].position - fs_in.worldPos);

        //Calcular productor escalar entre la direccion de la luz y el vector normal normalizado
        //para obtener la influencia de la luz difusa sobre cada superficie
        //max = no queremos el valor negativo del resultado
        float scalar = max(dot(N, lightDirection), 0.0);

        //Lo multiplicamos por la textura difusa
        vec3 diffuse = light[i].diffuse * scalar * vec3(texture(texture_diffuse, fs_in.textCoords));
        diffuse *= attenuation;
        
        // ---- ESPECULAR ----
        //Calcular la direccion entre la camara y la posicion en el mundo del vertice
        //Despues, la multiplicamos por la inversa de la TBN para pasarla a espacio tangente
        vec3 cameraDirection = fs_in.tbnMatrix * normalize(posCamera - fs_in.worldPos);
        //Calcular el reflejo del vector direccion de la luz con la normal
        vec3 directionReflect = reflect(-lightDirection, N);

        //Calcular el componente especular
        float S = pow(max(dot(cameraDirection, directionReflect), 0.0), material.brightness);
        vec3 specular = light[i].specular * S * vec3(texture(texture_specular, fs_in.textCoords));
        specular *= attenuation;

        //Resultado del calculo de la luz
        vec3 r = ambient + diffuse + specular;

        return r;
}

//Funcion que calcula la influencia de una luz dirigida o foco sobre el vertice
vec3 calculateSpotlight(int i, vec3 N){

        //Resultado del calculo de la luz
        vec3 r;

        // *** ATENUACION ***
        // a = 1/(1+kd²), donde d es la distancia entre la luz y el vertice y k es una constante predefinida por nosotros para controlar la atenuacion
        // Tras calcularla, la atenuacion debe multiplicarse por la componente ambiente, difusa y especular de la luz
        float d = length(light[i].position - fs_in.worldPos);
        float attenuation = 1.0 / (1.0 + (light[i].k * pow(d,2))); 

        //Calcular la direccion entre la fuente de luz y la posicion en el mundo del vertice
        vec3 lightDirection =normalize(light[i].position - fs_in.worldPos);

        //Comprobar si el vertice esta dentro del foco mediante el producto escalar entre el vector direccion de la luz y el vector entre la luz y el vertice
        float inside = dot(lightDirection, normalize(vec3(-light[i].direction))); 

        //La multiplicamos por la inversa de la TBN para pasarla a espacio tangente despues de comprobar si el vertice esta dentro del foco
        //En caso contrario, la comprobacion no se realiza correctamente
        lightDirection = fs_in.tbnMatrix * lightDirection;

        //Si el vertice esta dentro del foco, se realizan los calculos normales
        if ( inside > light[i].cut ){

            // ---- AMBIENTE ----
            //Se multiplica la componente ambiente de la luz por el color del ambiente del pixel para calcular la incidencia de la luz difusa
            //Solo se multiplica por la componente ambiente de la primera luz, sino la escena se satura demasiado
            vec3 ambient = light[i].ambient * vec3(texture(texture_diffuse, fs_in.textCoords));
            ambient *= attenuation;
            
            // ----- DIFUSA -----
            //Calcular productor escalar entre la direccion de la luz y el vector normal normalizado
            //para obtener la influencia de la luz difusa sobre cada superficie
            //max = no queremos el valor negativo del resultado
            float scalar = max(dot(N, lightDirection), 0.0);

            //Lo multiplicamos por la textura difusa
            vec3 diffuse = light[i].diffuse * scalar * vec3(texture(texture_diffuse, fs_in.textCoords));
            diffuse *= attenuation;
            
            // ---- ESPECULAR ----
            //Calcular la direccion entre la camara y la posicion en el mundo del vertice
            //Despues, la multiplicamos por la inversa de la TBN para pasarla a espacio tangente
            vec3 cameraDirection = fs_in.tbnMatrix * normalize(posCamera - fs_in.worldPos);
            //Calcular el reflejo del vector direccion de la luz con la normal
            vec3 directionReflect = reflect(-lightDirection, N);

            //Calcular el componente especular
            float S = pow(max(dot(cameraDirection, directionReflect), 0.0), material.brightness);
            vec3 specular = light[i].specular * S * vec3(texture(texture_specular, fs_in.textCoords));
            specular *= attenuation;

            // ---- SOMBRAS ----
            //Calculamos el valor de sombra
            float shadow = calculateShadows(fs_in.worldLightPos, i, N);
            //Lo multiplicamos por las componentes difusa y especular
            diffuse = (1.0 - shadow) * diffuse;
            specular = (1.0 - shadow) * specular;
            
            //Color final del fragmento = suma de las tres componentes
            r = ambient + diffuse + specular;
        }else{
            //Si no esta dentro del foco, se calcula solo la ambiente para que no este totalmente a oscuras el objeto
            vec3 ambient = light[i].ambient * vec3(texture(texture_diffuse, fs_in.textCoords));
            ambient *= attenuation;
            r = ambient;
        }

        return r;

}

//Funcion para el calculo de las sombras. Devuelve un float (grado de penumbra) que se multiplica por las 
//componentes difusa y especular de la luz 
float calculateShadows(vec4 Lpos, int luz, vec3 N){
    //Normalizar las coordenadas del vertice en el espacio de la luz -> dividir las coordenadas x,y,z por w
    vec3 normCoords = Lpos.xyz/Lpos.w;
    //Transformar las coordenadas normalizadas del rango [-1,1] al rango [0,1]
    normCoords = normCoords * 0.5 + 0.5; 
    //Obtener la profundidad actual de fragmento
    float aDepth = normCoords.z;
    //BIAS = Variable que sirve como rango para evitar el problema del acne en el dibujado de las sombras
    //Sin ella, se dibujan finas lineas negras por toda la escena iluminada, produciendo un efecto parecido a una teselacion
    //Se calcula a partir del angulo de cada superficie respecto al vector direccion de la luz
    vec3 lightDirection = normalize(light[luz].position - fs_in.worldPos);
    //Segun el angulo, se concede un valor de 0.001 (max) o 0.0001 
    float bias = max(0.001 * (1.0 - dot(N, lightDirection)), 0.0001);
    //Se aplica la tecnica del PCF, para difuminar los bordes de las sombras, ya que estos (especialmente los diagonales)
    //se ven escalonados
    float shadow = 0.0;
    //Recogemos el tamaño del mapa de profundidad
    //Al dividir 1.0 entre este, hacemos que ninguna de las muestras que trataremos despues tenga la misma profundidad
    vec2 sampleSize = 1.0 / textureSize(shadowMap, 0);
    //Bucle para tratar todas las muestras,en este caso 9
    for(int i = -1; i <= 1; i++)
    {
        for(int j = -1; j <= 1; j++)
        {
            //Obtenemos la profundidad mas cercana de cada una de las muestras
            float pcfDepth = texture(shadowMap, normCoords.xy + vec2(i, j) * sampleSize).r; 
            //Sumamos iteradamente al valor de sombra resultante
            //Si la profundidad del fragmento es mayor que la profundidad mas cercana desde la perspectiva de la luz,
            //entonces el fragmento se encuentro en penumbra
            shadow += aDepth - bias > pcfDepth ? 1.0 : 0.0;        
        }    
    }
    //Dividimos el valor de sombra entre el numero de muestras tratadas para hacer la media
    shadow /= 9.0;
    //Si la profundidad de las coordenadas del fragmente superan el 1.0 (maximo en coordenadas normalizadas) entonces no hay ninguna sombra posible
    if(normCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}